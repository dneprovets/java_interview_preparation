Java Interview Preparation (Collections)
--------------------------
##### Содержание  
[Чем отличается ArrayList от LinkedList?](#arraylist_vs_linkedlist)    
[Что вы обычно используете (ArrayList или LinkedList)? Почему?](#whyandwhat)    
[Что быстрее работает ArrayList или LinkedList?](#whatfaster)  
[Необходимо добавить 1млн. элемент, какую структуру вы используете?](#onemillion)  
[Как происходит удаление элементов из ArrayList? Как меняется в этом случае размер ArrayList?](#arraylistdel)    
[Предложите эффективный алгоритм удаления нескольких рядом стоящих элементов из середины списка, реализуемого ArrayList.](#effectivealgorythm)  
[Как устроена HashMap?](#hashmap)  
[Какое начальное количество корзин в HashMap?](#bucketcount)  
[Какая оценка временной сложности выборки элемента из HashMap? Гарантирует ли HashMap указанную сложность выборки элемента?](#hashmapgarantee)  
[Роль equals и hashCode в HashMap?](#equals)  
[Максимальное число значений hashCode()?](#hashcodemax)   
[Как и когда происходит увеличение количества корзин в HashMap?](#loadfactor)  
[В каком случае может быть потерян элемент в HashMap?](#loseelement)  
[Почему нельзя использовать byte[] в качестве ключа в HashMap?](#byte)  
[В чем отличия TreeSet и HashSet?](#treehash)  
[Устройство TreeSet?](#treeset)  
[Что будет, если добавлять элементы в TreeSet по возрастанию?](#increaseset)  
[Устаревшие коллекции](#old)  
[Синхронизированные коллекции](#sync)  



<a name="arraylist_vs_linkedlist"/>
## 1.Чем отличается ArrayList от LinkedList?  

ArrayList это список, реализованный на основе массива.  
LinkedList — это классический связный список, основанный на объектах с ссылками между ними.  

**Преимущества ArrayList**: в возможности доступа к произвольному элементу по индексу за постоянное время (так как это массив), минимум накладных расходов при хранении такого списка, вставка в конец списка в среднем производится так же за постоянное время. В среднем потому, что массив имеет определенный начальный размер n (в коде это параметр capacity), по умолчанию n = 10, при записи n+1 элемента, будет создан новый массив размером (n * 3) / 2 + 1, в него будут помещены все элементы из старого массива + новый, добавляемый элемент. В итоге получаем, что при добавлении элемента при необходимости расширения массива, время добавления будет значительно больше, нежели при записи элемента в готовую пустую ячейку. Тем не менее, в среднем время вставки элемента в конец списка является постоянным. Удаление последнего элемента происходит за константное время. Недостатки ArrayList проявляются при вставке/удалении элемента в середине списка — это взывает перезапись всех элементов размещенных «правее» в списке на одну позицию влево, кроме того, при удалении элементов размер массива не уменьшается, до явного вызова метода trimToSize().   

**LinkedList наоборот**, за постоянное время может выполнять вставку/удаление элементов в списке (именно вставку и удаление, поиск позиции вставки и удаления сюда не входит). Доступ к произвольному элементу осуществляется за линейное время (но доступ к первому и последнему элементу списка всегда осуществляется за константное время — ссылки постоянно хранятся на первый и последний, так что добавление элемента в конец списка вовсе не значит, что придется перебирать весь список в поисках последнего элемента). В целом же, LinkedList в абсолютных величинах проигрывает ArrayList и по потребляемой памяти и по скорости выполнения операций. LinkedList предпочтительно применять, когда происходит активная работа (вставка/удаление) с серединой списка или в случаях, когда необходимо гарантированное время добавления элемента в список.  

<a name="whyandwhat"/>
## 2.Что вы обычно используете (ArrayList или LinkedList)? Почему?  

В 90% случае ArrayList будет быстрее и экономичнее LinkedList, так что обычно используют ArrayList, но тем не менее всегда есть 10% случаев для LinkedList.  

Обычно ArrayList использую, ссылаясь на тесты и последний абзац из предыдущего вопроса, но не забываю и про LinkedList.

<a name="whatfaster"/>
## 3.Что быстрее работает ArrayList или LinkedList?  

Правильным же действием будет встречный вопрос о том, какие действия будут выполняться над структурой. В итоге, диалог плавно переходит к ответу на первый вопрос.

<a name="onemillion"/>
## 4. Необходимо добавить 1млн. элемент, какую структуру вы используете?

Нужно задавать дополнительные вопросы:    
в какую часть списка происходит добавление элементов?   
есть ли информация о том, что потом будет происходить с элементами списка?   какие то ограничения по памяти или скорости выполнения?   

<a name="arraylistdel"/>
##5. Как происходит удаление элементов из ArrayList? Как меняется в этом случае размер ArrayList?

При удалении произвольного элемента из списка, все элементы находящиеся «правее» смещаются на одну ячейку влево и реальный размер массива (его емкость, capacity) не изменяется никак. Механизм автоматического «расширения» массива существует, а вот автоматического «сжатия» нет, можно только явно выполнить «сжатие» командой trimToSize().

<a name="effectivealgorythm" />
##6. Предложите эффективный алгоритм удаления нескольких рядом стоящих элементов из середины списка, реализуемого ArrayList.

Допустим нужно удалить n элементов с позиции m в списке. Вместо выполнения удаления одного элемента n раз (каждый раз смещая на 1 позицию элементы, стоящие «правее» в списке), нужно выполнить смещение всех элементов, стоящих «правее» n+m позиции на n элементов левее к началу списка. Таким образом, вместо выполнения n итераций перемещения элементов списка, все выполняется за 1 проход.

<a name="hashmap" />
##7. Как устроена HashMap?

HashMap состоит из «корзин» (bucket`ов).  
С технической точки зрения «корзины» — это элементы массива, которые хранят ссылки на списки элементов.  
При добавлении новой пары ключ-значение, вычисляет хеш-код ключа, на основании которого вычисляется номер корзины (номер ячейки массива), в которую попадет новый элемент.   
Если корзина пустая, то в нее сохраняется ссылка на вновь добавляемый элемент, если же там уже есть элемент, то происходит последовательный переход по ссылкам между элементами в цепочке, в поисках последнего элемента, от которого и ставится ссылка на вновь добавленный элемент.  
Если в списке был найден элемент с таким же ключом, то он заменяется. Добавление, поиск и удаление элементов выполняется за константное время.   
Вроде все здорово, с одной оговоркой, хеш-функций должна равномерно распределять элементы по корзинам, в этом случае временная сложность для этих 3 операций будет не ниже lg N, а в среднем случае как раз константное время.

<a name="bucketcount" />
##8. Какое начальное количество корзин в HashMap?

Довольно неожиданный вопрос, опять же меня он когда-то заставил угадывать число корзин при использовании конструктора по умолчанию.

Ответ здесь — **16**. Cтоит заметить, что можно используя конструкторы с параметрами: через параметр capacity задавать свое начальное количество корзин.

<a name="hashmapgarantee" />
##9. Какая оценка временной сложности выборки элемента из HashMap? Гарантирует ли HashMap указанную сложность выборки элемента?

Константное время необходимо для выборки элемента. 

Если вы возьмете хеш-функцию, которая постоянно будет возвращать одно и то же значение, то HashMap превратится в связный список, с отвратной производительностью. Затем даже, если вы будете использовать хеш-функцию с равномерным распределением, в предельном случае гарантироваться будет только временная сложность lg N. Так что, ответ на вторую часть вопроса — нет, не гарантируется.

<a name="equals"/>
##10. Роль equals и hashCode в HashMap?

hashCode позволяет определить корзину для поиска элемента, а equals используется для сравнения ключей элементов в списке внутри корзины и искомого ключа.

<a name="hashcodemax"/>
##11. Максимальное число значений hashCode()?

Нужно вспомнить сигнатуру метода: int hashCode(). То есть число значений равно диапазону типа int — 2^32 (точного диапазона никогда не спрашивали, хватало такого ответа).

<a name="loadfactor"/>
##12. Как и когда происходит увеличение количества корзин в HashMap?

Помимо capacity в HashMap есть еще параметр loadFactor, на основании которого, вычисляется предельное количество занятых корзин (capacity*loadFactor). По умолчанию loadFactor = 0,75. По достижению предельного значения, число корзин увеличивается в 2 раза. Для всех хранимых элементов вычисляется новое «местоположение» с учетом нового числа корзин.

<a name="loseelement" />
##13. В каком случае может быть потерян элемент в HashMap?

Допустим в качестве ключа используется не примитив, а объект с несколькими полями. После добавления элемента в HashMap у объекта, который выступает в качестве ключа, изменяют одно поле, которое участвует в вычислении хеш-кода. В результате при попытке найти данный элемент по исходному ключу, будет происходить обращение к правильной корзине, а вот equals (ведь equals и hashCode должны работать с одним и тем же набором полей) уже не найдет указанный ключ в списке элементов. Тем не менее, даже если equals реализован таким образом, что изменение данного поля объекта не влияет на результат, то после увеличения размера корзин и пересчета хеш-кодов элементов, указанный элемент, с измененным значением поля, с большой долей вероятности попадет совсем в другую корзину и тогда он уже совсем потеряется.

<a name="byte" />
##14. Почему нельзя использовать byte[] в качестве ключа в HashMap?

Хеш-код массива не зависит от хранимых в нем элементов, а присваивается при создании массива (метод вычисления хеш-кода массива не переопределен и вычисляется по стандартному Object.hashCode() на основании адреса массива). Так же у массивов не переопределен equals и выполняет сравнение указателей. Это приводит к тому, что обратиться к сохраненному с ключом-массивом элементу не получится при использовании другого массива такого же размера и с такими же элементами, доступ можно осуществить лишь в одном случае — при использовании той же самой ссылки на массив, что использовалась для сохранения элемента. За ответ на этот вопрос отдельная благодарность уходит пользователю dark_dimius.

<a name="treehash">
##15. В чем отличия TreeSet и HashSet?

Set — это множество (так же называют «набором»).  
**Set** не допускает хранение двух одинаковых элементов. Формально говоря, термин «множество» и так обозначает совокупность различных элементов, очень важно, что именно различных элементов, так как это главное свойство Set. С учетом такого определения, пояснение про хранение одинаковых элементом не требуется, но в обиходе, понятие «множество» потеряло свой строгий смысл касательно уникальности элементов, входящих в него, поэтому все же уточняйте отдельно данное свойство множества.

**TreeSet** обеспечивает упорядоченно хранение элементов в виде красно-черного дерева. Сложность выполнения основных операций в TreeSet lg N.  
**HashSet** использует для хранения элементов такой же подход, что и HashMap, за тем отличием, что в HashSet в качестве ключа выступает сам элемент, кроме того HashSet (как и HashMap) не поддерживает упорядоченное хранение элементов и обеспечивает временную сложность выполнения операций аналогично HashMap.

<a name="treeset">
##16. Устройство TreeSet?

TreeSet основан на красно-черном дереве. 

<a name="increaseset">
##17. Что будет, если добавлять элементы в TreeSet по возрастанию?

TreeSet лежит бинарное дерево и если добавлять элементы по возрастанию, то как они будут распределены по дереву.

Все элементы после доабвления в обычное бинарное дерево будут находится в одной ветви длиной N элементов, что сводит на нет, все преимущества такой структуры, как дерево (фактически получается список). 

В основе TreeSet лежит красно-черное дерево, которое умеет само себя балансировать. В итоге, TreeSet все равно в каком порядке вы добавляете в него элементы, преимущества этой структуры данных будут сохраняться.

<a name="old" />
##Устаревшие коллекции

Следующие коллекции являются устаревшими, и их использование не рекомендуется, но не запрещается.  

+ Enumeration — аналог интерфейса Iterator.
 
+ Vector — аналог класса ArrayList; поддерживает упорядоченный список элементов, хранимых во "внутреннем" массиве.
 
+ Stack — класс,  производный от Vector,  в который добавлены методы вталкивания (push) и выталкивания (pop) элементов,  так что список может трактоваться в терминах, принятых для описания структуры данных стека (stack).
 
+ Dictionary — аналог интерфейса Map, хотя представляет собой абстрактный класс, а не интерфейс.
 
+ Hashtable — аналог HashMap.

Все методы Hashtable, Stack, Vector являются синхронизированными, что делает их менее эффективными в одно поточных приложениях.

<a name="sync">
##Синхронизированные коллекции

Получить синхронизированные объекты коллекций можно с помощью статических методов synchronizedMap и synchronizedList класса Collections.

  Map m = Collections.synchronizedMap(new HashMap());
  List l = Collections.synchronizedList(new ArrayList());
  
Синхронизированные обрамления коллекций synchronizedMap и synchronizedList иногда называют условно потоко безопасными - все операции в отдельности потоко безопасны, но последовательности операций, где управляющий поток зависит от результатов предыдущих операций, могут быть причиной конкуренции за данные. 

Условная безопасность потоков, обеспечиваемая synchronizedList и synchronizedMap представляет скрытую угрозу - разработчики полагают, что, раз эти коллекции синхронизированы, значит, они полностью потоко безопасны, и пренебрегают должной синхронизацией составных операций.   

В результате, хотя эти программы и работают при лёгкой нагрузке, но при серьёзной нагрузке они могут начать выкидывать NullPointerException или ConcurrentModificationException.

Кроме того всегда существует возможность "классической" синхронизации с помощью блока synchronized.

